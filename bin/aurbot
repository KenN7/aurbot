#!/usr/bin/python3
# coding: utf-8

# aurbot - Archlinux User Repository Builder Bot
# Copyright © 2014 Sébastien Luttringer
# Started, October 30th 2011
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

import os
import time
import json
import glob
import shutil
import argparse
import tempfile
import tarfile
import urllib.request
import configparser
import subprocess
import pyalpm
import AUR

class Repositories(dict):
	'''
	Repository class abstract all stuff around repositories
	'''

	def init(self, repo):
		'''
		Init a repository
		'''
		# create repository path
		if self[repo]['path'] is not None:
			os.makedirs(self[repo]['path'], exist_ok=True)
		# create chroot
		if self[repo]['chroot'] is not None:
			root = os.path.join(self[repo]['chroot'], 'root')
			if not os.path.exists(root):
				os.makedirs(self[repo]['chroot'], exist_ok=True)
				cmds = ['mkarchroot', '-n', root, 'base', 'base-devel', 'sudo']
				if self[repo]['arch'] == 'i686':
					cmds.insert(0, 'linux32')
				elif self[repo]['arch'] == 'x86_64':
					cmds.insert(0, 'linux64')
				if os.geteuid() != 0:
					cmds.insert(0, 'sudo')
				subprocess.check_call(cmds, close_fds=True)

	def load(self, conf_path, db_path):
		'''
		Load repositories configuration
		'''
		try:
			# read config
			cp = configparser.RawConfigParser()
			cp.read(conf_path)
			for sec in cp.sections():
				self[sec] = {
					'dbname': '%s.db.tar.gz' % sec,
					'arch': None,
					'path': None,
					'chroot': None,
					'build_command': None,
					'statusdb': None}
				self[sec].update(cp.items(sec))
				self[sec]['packages'] = cp.get(sec, 'packages', fallback='').split()
				# checks
				if self[sec]['arch'] not in ('x86_64', 'i686'):
					raise Exception('Invalid arch')
				if self[sec]['path'] is None:
					raise Exception('Invalid repository path')
		except Exception as e:
			print('Unable to load package database: %s' % e)

	def tobuild(self):
		'''
		List of packages to build
		'''
		for repo in self:
			for pkg in self[repo]['packages']:
				yield (repo, pkg)

	def build(self, repo, path):
		'''
		Build package package inside repo
		'''
		cwd = os.getcwd()
		try:
			# chdir inside builddir
			os.chdir(path)
			# output fd
			if verbose == 2:
				 devnull = None
			else:
				devnull = open('/dev/null', 'w')
			# define run commands
			cmds = ['makechrootpkg', '-c', '-r', self[repo]['chroot']]
			if self[repo]['arch'] == 'i686':
				cmds.insert(0, 'linux32')
			elif self[repo]['arch'] == 'x86_64':
				cmds.insert(0, 'linux64')
			if os.geteuid() != 0:
				cmds.insert(0, 'sudo')
			# run build
			subprocess.check_call(cmds, stdout=devnull, stderr=devnull, close_fds=True)
		finally:
			os.chdir(cwd)

	def add(self, repo, files=[]):
		'''
		Add pkg to repo
		'''
		dbpath = os.path.join(self[repo]['path'], self[repo]['dbname'])
		for f in files:
			dstpath = os.path.join(self[repo]['path'], os.path.basename(f))
			shutil.copy(f, dstpath)
			subprocess.check_call(['repo-add', dbpath, dstpath], close_fds=True)

	def all_packages(self):
		'''
		Return a set of all pacakges
		'''
		pkgs = set()
		for repo in self:
			for pkg in self[repo]['packages']:
				pkgs.add(pkg)
		return pkgs


class AURPackages(dict):
	'''
	Packages class handle package informations
	'''

	aur_url = 'https://aur.archlinux.org'
	aur_min_update_interval = 60

	def load(self, path):
		'''
		Load packages informations from a file
		'''
		if not os.path.exists(path):
			return
		try:
			self.update(json.load(open(path, "r")))
		except Exception as e:
			print('Unable to load package database: %s' % e)

	def save(self, path):
		'''
		Save packages informations to a file
		'''
		json.dump(self, open(path, 'w'))

	def register(self, pkg, update=False):
		if pkg not in self or update:
			self.aur_update(pkg)

	def aur_update(self, pkg):
		'''
		update information about a package
		'''
		if (pkg in self and
		    'aurbuilder_update' in self[pkg] and
		    self[pkg]['aurbuilder_update'] + self.aur_min_update_interval > time.time()):
			return
		info = AUR.aur_query('info', pkg)
		if info is not None:
			self[pkg] = info
			self[pkg]['aurbuilder_update'] = time.time()
		else:
			print('No package %s' % pkg)

	def extract(self, pkg, path):
		'''
		Extract aur source tarball inside a directory path
		'''
		# feed package db
		self.register(pkg)
		# get tarball
		fo = urllib.request.urlopen('%s/%s' % (self.aur_url, self[pkg]['URLPath']))
		# extract tarball
		tarball = tarfile.open(mode='r|*', fileobj=fo)
		tarball.extractall(path)

##################
#Printing commands
##################
def msg(message):
	if verbose > 0:
		print('\033[1;32m==>\033[m %s' % message)

def msg2(message):
	if verbose > 0:
		print('  \033[1;34m->\033[m %s' % message)

################
#Parser commands
################

def c_init(args):
	'''
	Init command
	'''
	msg('Initializing repositories')
	for repo in args.repos:
		msg2(repo)
		args.repos.init(repo)

def c_update(args):
	'''
	Update command
	'''
	msg('Updating AUR packages database')
	for pkg in sorted(args.repos.all_packages()):
		msg2(pkg)
		args.aurpkg.aur_update(pkg)

def c_build(args):
	'''
	Build command
	'''
	# start building
	for repo, pkg in args.repos.tobuild():
		try:
			msg('Building %s in %s' % (pkg, repo))
			# creating temp directory to extract tarball
			tempd = tempfile.TemporaryDirectory()
			# extract package inside tempdir
			msg2('Downloading from AUR')
			aurpkg.extract(pkg, tempd.name)
			# build package
			msg2('Compiling')
			builddir = os.path.join(tempd.name, pkg)
			args.repos.build(repo, builddir)
			files = glob.glob(os.path.join(builddir, '*.pkg.tar.xz'))
			if len(files) == 0:
				raise Exception('Unable to find binary packages')
			# add to repository
			msg2('Adding to repository')
			args.repos.add(repo, files)
		except Exception as e:
			# FIXME: mark package as invalid to build
			print('build failure: %s' % e)

# we start here
parser = argparse.ArgumentParser()
parser.add_argument('-r', '--repo-conf', default='repositories.conf', help='repository definitions')
parser.add_argument('-R', '--repo-db', default='repositories.json', help='repositories databases')
parser.add_argument('-p', '--aurpkg-db', default='packages.json', help='AUR packages database')
mg = parser.add_mutually_exclusive_group()
mg.add_argument('-q', '--quiet', action='store_true', default=False,
	help='quiet mode')
mg.add_argument('-v', '--verbose', action='store_true', default=False,
	help='verbose mode')

sp = parser.add_subparsers()
p_init = sp.add_parser('init')
p_init.set_defaults(func=c_init)
p_update = sp.add_parser('update')
p_update.set_defaults(func=c_update)
p_build = sp.add_parser('build')
p_build.set_defaults(func=c_build)

# parse args
args = parser.parse_args()

# path must be absolute!
args.repo_conf = os.path.abspath(args.repo_conf)
args.repo_db = os.path.abspath(args.repo_db)
args.aurpkg_db = os.path.abspath(args.aurpkg_db)

# set global output state
if args.verbose:
	verbose = 2
elif args.quiet:
	verbose = 0
else:
	verbose = 1

# load repo mananger
msg('Loading repositories configurations')
repos = Repositories()
repos.load(args.repo_conf, args.repo_db)

# load package manager
msg('Loading AUR pacakages database')
aurpkg = AURPackages()
aurpkg.load(args.aurpkg_db)

# add aurpkg and repos to args
args.aurpkg = aurpkg
args.repos = repos

# run command function
args.func(args)

# save aur packages db
msg('Saving AUR pacakages database')
aurpkg.save(args.aurpkg_db)
